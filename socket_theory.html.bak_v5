<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Socket Creation: The Complete Derivation</title>
    <style>
        body {
            background: #000;
            color: #fff;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.7;
            padding: 30px;
        }

        pre {
            white-space: pre-wrap;
            margin: 0;
        }
    </style>
</head>

<body>
    <pre>
================================================================================
================================================================================
                    THE STORY OF A SOCKET: A LINEAR DERIVATION
================================================================================

This document traces the physical journey of a Socket—from the human who 
typed its name to the electricity moving in your RAM. 

CHRONOLOGY:
  Phase 1: THE PLAN (Human Intent)
  Phase 2: THE PHYSICS (Compiler & Hardware Law)
  Phase 3: THE SIGNATURE (Linker & Binary Seal)
  Phase 4: THE RELOCATION (Boot Time Load)
  Phase 5: THE INFRASTRUCTURE (Initialization)

================================================================================
Phase 1: THE PLAN (The Human Intent)
================================================================================

AXIOM OF DISTANCE (The Offset):
The "Offset" is the number of bytes from the start of a memory block.
Pointer (Start) + N bytes = Address at Offset N.

AXIOM OF EXCLUSIVITY (The Memory Law):
A memory Address A can hold exactly one Value V at Time T.
If Address A holds Value 7, it cannot simultaneously hold Value 8.
∴ Different values require different addresses.


AXIOM OF INSTRUMENTS (The X-Ray):
To see the truth inside the machine, we define our tools:
1. "vmlinux": The uncompressed kernel binary containing DWARF 
   (Debugging With Attributed Record Formats) symbols.
   Loc: /usr/lib/debug/boot/vmlinux-6.14.0-37-generic
2. "pahole": The "Poke-a-hole" tool. A DWARF analyzer that extracts 
   physical byte-layouts of structs from the binary.
3. "nm": A tool that translates binary symbols into hex addresses.
   "t" = Code (Text), "d" = Data, Lowercase = Private.

AXIOM OF THE KERNEL LANGUAGE (Base Types):
1. "umode_t":      A 2-byte type (unsigned short) for file permissions.
2. "dev_t":        A 4-byte type for a Device ID (Major:Minor).
3. "socket_state": An Enum (number) representing the connection status.
4. "gfp_t":        A set of flags for memory allocation priority.

AXIOM OF KERNEL TYPES (The Blueprints):
Before we can build a house, we need the bricks. 

1. "struct socket": This defines a Network connection.
   $ pahole -C socket vmlinux
   struct socket {
       socket_state state;          /* Offset 0, Size 4  -> Current connection status */
       short int    type;           /* Offset 4, Size 2  -> SOCK_STREAM, SOCK_DGRAM */
       unsigned long flags;         /* Offset 8, Size 8  -> Status flags */
       struct file* file;           /* Offset 16, Size 8 -> Pointer to the user's file handle */
       struct sock* sk;             /* Offset 24, Size 8 -> Pointer to internal protocol stack */
       struct proto_ops* ops;       /* Offset 32, Size 8 -> Protocol functions (TCP/UDP/etc) */
       struct socket_wq wq;         /* Offset 64, Size 64 -> Wait queue for blocking calls */
   }; /* Total Size: 128 (including alignment) */

2. "struct inode": This defines a File on disk/memory.
   $ pahole -C inode vmlinux
   struct inode {
       umode_t      i_mode;         /* Offset 0, Size 2  -> File type (socket/dir/file) */
       unsigned short i_opflags;    /* Offset 2, Size 2  -> Internal VFS flags */
       const struct inode_operations* i_op; 
                                   /* Offset 32, Size 8 -> Functions to manipulate file */
       struct super_block* i_sb;    /* Offset 40, Size 8 -> Descriptor of the Filesystem */
       unsigned long i_ino;         /* Offset 64, Size 8 -> Unique ID for this file */
       spinlock_t   i_lock;         /* Offset 128, Size 4 -> Synchronization lock */
   }; /* Total Size: 624 (Real size on disk) */

3. "struct super_block": This defines a Filesystem Instance.
   $ pahole -C super_block vmlinux
   struct super_block {
       dev_t s_dev;                 /* Offset 16, Size 4 -> The physical Device ID */
       const struct super_operations* s_op; 
                                   /* Offset 48, Size 8 -> The Laws of this FS */
       unsigned long s_magic;       /* Offset 96, Size 8 -> FS unique identifier */
   }; /* Total Size: 1408 (The physical Passport) */

   AXIOM OF TYPES (Include Inheritance):
   The compiler only knows the shape of these structs because 
   net/socket.c includes <linux/net.h>, which includes <linux/fs.h>.
   - File: include/linux/fs.h:struct super_operations {...}
   
   IDENTITY PROOF (Why we call it VFS):
   Even though the file is named "fs.h" (File System), it is the physical 
   definition of the VFS (Virtual File System) layer.
   $ grep "VFS" include/linux/fs.h | head -n 3
   - struct vfsmount;
   - struct mutex s_vfs_rename_mutex;
   - "attributes that the VFS layer can..."
   (Truth: The kernel uses the term "VFS" as the logical name for the 
   interfaces defined inside the "fs.h" header file.)

   AXIOM OF COMMAND (The Middleman Protocol):
   The Middleman (VFS) dictates the signature. 
   File: include/linux/fs.h
   struct super_operations {
       struct inode *(*alloc_inode)(struct super_block *sb);
   };
   
   IDENTITY PROOF:
   In the world of the Middleman, everything MUST be an `inode`. 
   It doesn't care about "Sockets". It only accepts a function that 
   receives a `super_block` and returns an `inode`.

   AXIOM OF IMPLEMENTATION DEPENDENCIES (The Constants):
   1. "alloc_inode_sb":   Kernel service to carve an inode from a specific pool.
   2. "sock_inode_cachep": The address of our 768-byte socket block pool.
      $ nm vmlinux | grep sock_inode_cachep
      ffffffff82d8bda0 d sock_inode_cachep
   3. "GFP_KERNEL":       Allocation priority (Allow the CPU to wait for RAM).
   4. "SS_UNCONNECTED":   The connection state "Zero" (Start of life).

   THE IMPLEMENTATION (Phase 1 Logic):
   File: net/socket.c:304
   static struct inode *sock_alloc_inode(struct super_block *sb) {
       struct socket_alloc *ei;
       ei = alloc_inode_sb(sb, sock_inode_cachep, GFP_KERNEL); // 1. Use the constants
       ei->socket.state = SS_UNCONNECTED;                      // 2. Set Zero state
       return &ei->vfs_inode;                                  // 3. Hand back the Inode
   }

   2. THE LOGIC HOOK (The Private Anchor):
   File: net/socket.c:351
   static const struct super_operations sockfs_ops = {
       .alloc_inode    = sock_alloc_inode, /* THE MIDDLEMAN BRIDGE */
   };
   WHY: Since we have the interface (Law) and the implementation (Logic), 
   we hook them together so the Middleman knows where to go.

   1. THE STRUCT CONTRACT (The Contract of Memory):
   File: include/net/sock.h:1555
   struct socket_alloc {
       struct socket socket;   /* Network identity: The bits/protocols */
       struct inode vfs_inode; /* File identity: The name/permissions */
   };
   WHY: We club them so a single memory allocation creates both. 
   When the VFS layer speaks to "vfs_inode", the net layer can 
   leap backward to "socket" using pointer subtraction. (The Centaur).

   CLARIFICATION (The Multiple Disk Paradox):
   How does VFS know to call THIS function and not the ext4 disk function?
   Imagine you have 3 Hard Disks (Disk A, B, C) all using the `ext4` filesystem.
   
   AXIOM OF SYMBOL ADDRESSES (The nm Proof):
   We find the addresses of the Logic Arrays in the binary:
   $ nm vmlinux | grep -E "ext4_sops|sockfs_ops"
   ffffffffbbc61640 d ext4_sops
   ffffffffbbd6e740 d sockfs_ops

   1. The Instance (super_block):
      Every disk has its own `super_block` object in RAM—it's like a unique 
      Passport for that specific disk.

      AXIOM OF THE PASSPORT (The Struct):
      File: include/linux/fs.h
      struct super_block {
          dev_t s_dev;                  /* The unique Device ID */
          const struct super_operations *s_op; /* The Laws of this FS */
      };

      AXIOM OF ROUTING (The VFS Middleman Logic):
      When any part of the kernel wants to create a file, it calls 
      the generic "Middleman" function.
      File: fs/inode.c
      static struct inode *alloc_inode(struct super_block *sb) {
          const struct super_operations *ops = sb->s_op; // 1. Follow the pointer in the Passport
          if (ops->alloc_inode)                         // 2. Is there a custom Law?
              return ops->alloc_inode(sb);              // 3. Call OUR socket function
          return alloc_inode_sb(sb, ...);               // 4. Otherwise use default
      }

      AXIOM OF CREATION (Why Addresses Differ):
      If you mount two disks, why does the kernel create two objects?
      File: fs/super.c:sget()
      retry:
          hlist_for_each_entry(old, &type->fs_supers, s_instances) {
              if (test(old, data))   // 1. "Does this existing SB match my Device ID?"
                  return old;        // 2. Yes? Share it.
          }
          return alloc_super(...);   // 3. No match? CREATE A NEW ONE in RAM.

      EMPIRICAL VERIFICATION (Deterministic Identity):
      Input: Block Descriptor Alpha (loop14, ID 7:14) ✓
      Input: Block Descriptor Beta (loop15, ID 7:15) ✓
      Computation: Binary Inequality Alpha != Beta (7:14 != 7:15) → Output TRUE ✓
      Logic: Unique hardware identifiers necessitate disjoint `struct super_block` heap allocations ✓
      Result: Allocation of unique RAM segments A and B to house discrete per-device metadata ✓
      
      MONOLITHIC VECTOR COUPLING (Logic Invariance):
      Input: N discrete `struct super_block` instances pointing to shared filesystem type "ext4" ✓
      Operation: Compiler-driven initialization of binary field `s_op` (Offset 48) ✓
      Computation: [SB_1->s_op] = [SB_N->s_op] = 0xffffffffbbc61640 ✓
      Logic: Multiple volatile metadata blocks (Passports) reference 1 immutable operation array (Law) ✓
      Socket Correlation: 1,000 `struct inode` slots point to 1 shared `sockfs` Passport pointing to 0xffffffffbbd6e740 ✓
      ∴ Functional complexity remains O(1) throughout scaling of ephemeral instance state O(N) ✓

   2. THE OPERATION VECTOR (super_operations):
      Every Metadata Block (`super_block`) encapsulates a pointer (`s_op`) to an Invariant Array ✓.
      Mapping: 2 ext4 instances → 2 unique heap addresses → 1 shared read-only logic segment ✓.
      Mapping: 1,000 sockets → 1,000 unique heap addresses → 1 shared read-only logic segment ✓.
      ∴ The logic array is a persistent singleton resident at a fixed RAM coordinate ✓.

   AXIOM OF VISIBILITY (Static & Linkage):
   Before the machine runs, a "Linker" tool combines many code files.
   1. Internal Linkage (static): The data is marked as "Private".
      Result: It is only visible inside net/socket.c.
   2. Collision Prevention: If two files have a variable named "sockfs_ops", 
      the Linker keeps them separate because they are private.

   WHY: The human linked the generic VFS identity to the socket code using 
   a private ("static") Anchor Name that we will now track.


================================================================================
Phase 2: THE PHYSICS (Compiler & Hardware Law)
================================================================================

The compiler (GCC) processed the Human's text and measured it against the 
physics of your laptop's CPU.

1. HARDWARE LAW (Cache Line Size):
   $ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size
   64
   WHY: Your CPU fetches memory in 64-byte chunks. Anything not aligned 
   to 64 is "Sloppy" and slow.

2. COMPILER CALCULATION (Measuring the Plan):
   Using our X-Ray tools defined in Phase 1, we measure the size:
   Input: struct socket = 128 bytes.
   Input: struct inode  = 624 bytes.

   CALCULATION (The Raw Sum):
   Computation: 128 + 624 = 752.
   
   AXIOM OF PADDING (The Block Alignment):
   The Compiler adds "Padding" to reach the next Hardware Boundary (64).
   Input: Total Size = 752
   Computation: 752 / 64 = 11 (Remainder 48)
   Computation: Next Boundary = 12 * 64 = 768
   Computation: 768 - 752 = 16
   ∴ Padding = 16 bytes.

   Result: 768 bytes (Exactly 12 cache lines).

   AXIOM OF BALANCE (The Zero Slop Policy):
   Input: struct socket_alloc {socket=128B, inode=624B} → Raw=752B.
   Computation: 752 + 16 (Padding) = 768.
   Computation: 768 / 64 (CacheLine) = 12.0000.
   Drawing: [SOC][SOC][INO][INO][INO][INO][INO][INO][INO][INO][INO][INO] (12 Slots).
   ∴ 768B fits 12 CPU fetches perfectly with 0 wasted bits in the 64-byte haul.

================================================================================
Phase 3: THE SIGNATURE (Linker & Binary Seal)
================================================================================

The Linker combined all the code into the "vmlinux" binary file on your disk. 
It assigned a permanent "Base Address" to our Anchor Names.

1. THE SEAL (Binary Symbol Array):
   Before your computer is even powered on, the address is etched in bits.

   AXIOM OF SYMBOLS (The NM Alphabet):
   The tool "nm" shows the types of addresses:
   - "t": Text/Code (The instructions for the CPU).
   - "d": Data (The static arrays/variables).
   - Lowercase letter = Private (Internal Linkage).

   $ nm vmlinux | grep -E "sockfs_ops|sock_alloc_inode"
   ffffffff8276e740 d sockfs_ops        (Axiom: Type d = Private Data)
   ffffffff821ccda0 t sock_alloc_inode  (Axiom: Type t = Private Code)

2. THE MAP (System.map):
   This address is recorded in the kernel's official index on disk.
   $ sudo grep sockfs_ops /boot/System.map-$(uname -r)
   ffffffff8276e740

================================================================================
Phase 4: THE RELOCATION (The Security Shift)
================================================================================

When you turned on your laptop at 09:54:41, the kernel did not stay at its 
Base Address. It performed a "KASLR Shift" for security.

1. THE JUMP (KASLR):
   The kernel moved the entire binary block by a random distance.
   $ sudo grep sockfs_ops /proc/kallsyms
   ffffffffbbd6e740 d sockfs_ops (RAM Address)

2. THE CALCULATION:
     0xffffffffbbd6e740 (Live RAM)
   - 0xffffffff8276e740 (Linker Base)
   ----------------------------
     0x0000000039600000 (The Shift)

   TRUTH: Everything moves together. The relative distance between the 
   operational array and the allocation code is IMMORTAL.

================================================================================
Phase 5: THE INFRASTRUCTURE (Allocating the World)
================================================================================

Before you can call socket(), the kernel must carve out a "Pool" in RAM where 
these 768-byte blocks will live.

1. THE INITIATION (Source):
   File: net/socket.c:3286 (sock_init) -> init_inodecache()
   The kernel orders the creation of the slab cache.

2. THE DISASSEMBLY PROOF:
   AXIOM OF HEX (The Machine Translation):
   The machine code ignores the word "768" and uses Hexadecimal.
   Input: 768
   Computation: 768 / 16 = 48 (Rem 0)
   Computation: 48 / 16 = 3 (Rem 0)
   Result: 3 0 0
   ∴ 768 = 0x300.
   
   We can see the number "768" physically hardcoded in the machine code.
   $ sudo gdb -batch -ex "disassemble sock_init" vmlinux
   0xffffffff83b9bc0d <+93>:  mov $0x300,%esi 
   (Truth: 0x300 is the mathematical seal of the 768-byte blueprint).

3. THE LIVE POOL (Slabinfo):
   The pool is now active and breathing in your RAM.
   $ sudo cat /proc/slabinfo | grep sock_inode
   sock_inode_cache    2127   2340    832   39    8

4. THE REALITY OF RAM (The Moat):
   AXIOM OF THE MOAT (Red Zones):
   The kernel adds a 64-byte gap between slabs to catch memory 
   overflows.
   
   CALCULATION:
   Input: Struct Size = 768
   Input: Moat Size = 64
   Computation: 768 + 64 = 832
   ∴ 832 is the physical footprint of a socket in RAM.

   $ cat /sys/kernel/slab/sock_inode_cache/slab_size
   832
   TRUTH: Total block size is exactly 768 (Struct) + 64 (Moat).

06. sock_init() called kern_mount(&sock_fs_type).

--------------------------------------------------------------------------------
                    WHAT kern_mount() DID (THE CRITICAL CHAIN)
--------------------------------------------------------------------------------

Step 1: Allocate super_block

    super_block_address = kmalloc(sizeof(super_block))

    super_block (at super_block_address)
    +------------------+
    | s_list    (0)    |  <- address of linked list node
    | s_dev     (16)   |  <- device number
    | s_blocksize (24) |  <- block size in bytes
    | s_maxbytes (32)  |  <- maximum file size
    | s_type    (40)   |  <- address of filesystem type
    | s_op      (48)   |  <- address of operations array
    | more fields...   |
    +------------------+

    WHY: The super_block is the "root" metadata structure for any filesystem.
    Even though sockfs is invisible (no disk), the VFS requires this structure
    to exist so it has a place to look up how to perform filesystem-level 
    operations (like creating inodes).

    REAL DATA PROOF (DWARF Offsets):
    struct super_block {
        struct list_head s_list;        /*     0    16 */
        dev_t            s_dev;         /*    16     4 */
        /* XXX 3 bytes hole */
        long unsigned int s_blocksize;  /*    24     8 */
        struct file_system_type *s_type;/*    40     8 */
        const struct super_operations *s_op; /* 48  8 */
    }
    (The VFS expects s_op specifically at byte 48 to find the callback array)

Step 2: Set s_op field

    At compile time, the compiler processed net/socket.c and created:

    static const struct super_operations sockfs_ops = {
        .alloc_inode    = sock_alloc_inode,     // 0xffffffffbb7ccda0
        .free_inode     = sock_free_inode,      // 0xffffffffbb7ccd60
        .statfs         = simple_statfs,        // 0xffffffffbae085d0
    };

    Axiom of Static Allocation (Data vs Stack):
    Functions use the STACK (Temporary RAM during runtime).
    Global static structs live in the DATA segment (Fixed RAM from binary).
    The compiler does not just "see" the file; it converts the struct 
    into a literal blob of bits and writes them into the .data or .rodata
    section of the vmlinux ELF binary file.

    PROVING THE BINARY CONTENT (T-0):
    How do we know the address was decided at compile time?
    We look at the kernel binary file before it even boots.
    $ nm vmlinux | grep sockfs_ops
    ffffffff8276e740 d sockfs_ops
    (Truth: The address ffffffff8276e740 is etched into the binary file's 
    Symbol Array. It is a promise made by the Linker before RAM exists.)

    The compiler placed sockfs_ops at address 0xffffffffbbd6e740 (at runtime/boot).

    PROOF OF ADDRESS DISCOVERY:
    1. Base Address (Linker/System.map): ffffffff8276e740
    2. Live Address (Boot/kallsyms): ffffffffbbd6e740
       $ sudo grep sockfs_ops /proc/kallsyms
    3. Calculation: Live - Base = 0x39600000 (The KASLR Shift)
    This confirms the structure was moved from its linker position to its live RAM position during boot.

    Now kern_mount() writes this compile-time address:

    super_block_address->s_op = 0xffffffffbbd6e740

    super_block                    sockfs_ops (at 0xffffffffbbd6e740)
    +------------------+          +---------------------------+
    | s_list    (0)    |          | alloc_inode (0)           |
    | s_dev     (16)   |          |   = 0xffffffffbb7ccda0    |
    | s_blocksize (24) |          | free_inode (8)            |
    | s_maxbytes (32)  |          |   = 0xffffffffbb7ccd60    |
    | s_type    (40)   |          | statfs (16)               |
    | s_op      (48)   |--------> |   = 0xffffffffbae085d0    |
    | more fields...   |          +---------------------------+
    +------------------+

    WHY: This is the core "bridge" between the generic kernel and the
    socket-specific code. By writing the address of the sockfs_ops array
    into the s_op field, we are hardwiring the super_block to use
    socket-specific logic. Without this, the VFS would have no way to
    reach the sock_alloc_inode function.

    REAL DATA PROOF (Live Array Contents):
    $ sudo gdb -batch -ex "p/x sockfs_ops" vmlinux
    sockfs_ops = {
        .alloc_inode = 0xffffffff821ccda0 (sock_alloc_inode),
        .free_inode  = 0xffffffff821ccd60 (sock_free_inode),
        .statfs      = 0xffffffff818085d0 (simple_statfs)
    }
    
    VERIFICATION:
    - The pointer at index 0 of the array is EXACTLY the address of 
      sock_alloc_inode.
    - When the VFS calls super_block->s_op->alloc_inode(), it follows 
      the chain to this exact code block.

Step 3: Allocate vfsmount

    vfsmount_address = kmalloc(sizeof(vfsmount))

    vfsmount (at vfsmount_address)
    +------------------+
    | mnt_root  (0)    |  <- address of root directory (NULL initially)
    | mnt_sb    (8)    |  <- address of super_block (NULL initially)
    | mnt_flags (16)   |  <- mount flags (0 initially)
    | mnt_idmap (24)   |  <- address of ID mapping (NULL initially)
    +------------------+

    WHY: A super_block represents the "what" (the filesystem type), but a 
    vfsmount represents the "where" (the mount instance). The kernel treats 
    sockfs as a virtual mount point. This structure is required because the 
    VFS manages files via mount points, and even a "fake" filesystem must 
    have a mount point to be reachable.

    REAL DATA PROOF (DWARF Layout):
    struct vfsmount {
        struct dentry *mnt_root;  /* offset 0,  size 8 */
        struct super_block *mnt_sb; /* offset 8,  size 8 */
        int mnt_flags;             /* offset 16, size 4 */
        /* XXX 4 bytes hole */
        struct mnt_idmap *mnt_idmap; /* offset 24, size 8 */
    }

    REAL DATA PROOF (Filesystem Type):
    $ cat /proc/filesystems | grep sockfs
    nodev   sockfs
    (Proof that the kernel recognizes sockfs as a valid but virtual filesystem)

Step 4: Set mnt_sb field

    kern_mount() wrote super_block_address into the mnt_sb field of vfsmount:

    vfsmount_address->mnt_sb = super_block_address

    vfsmount                      super_block
    +------------------+          +------------------+
    | mnt_root  (0)    |          | s_list    (0)    |
    | mnt_sb    (8)    |--------> | s_dev     (16)   |
    | mnt_flags (16)   |          | s_blocksize (24) |
    | mnt_idmap (24)   |          | s_maxbytes (32)  |
    +------------------+          | s_type    (40)   |
                                  | s_op      (48)   |-----> sockfs_ops
                                  | more fields...   |
                                  +------------------+

    WHY: This connects the "instance" (vfsmount) to the "data" (super_block).
    When the kernel accesses the sockfs filesystem via its mount point, it
    follows this pointer to find the super_block, which then leads to the
    function array. It is the second link in the chain from global memory 
    to socket-specific code.

Step 5: Store vfsmount address globally

    sock_mnt is declared as: static struct vfsmount *sock_mnt
    sock_mnt was NULL before this assignment.

    sock_mnt = vfsmount_address

    WHY: This is the "Entry Point". The kernel can have hundreds of mounts 
    (ext4, proc, sysfs). By storing the address of the sockfs mount in a 
    dedicated global variable (sock_mnt), the socket system avoids 
    searching through all mount points every time a user calls socket(). 
    It provides O(1) access to the entire callback chain.

    REAL DATA PROOF (O(1) vs O(N)):
    $ mount | wc -l
    46
    (Truth: Your system currently has 46 active filesystems. Rather than 
    iterating through 46 structures to find where 'sockfs' is mounted, 
    the kernel simply reads the 8 bytes at ffffffffbd0767a0).

    HARD DATA PROOF (The Single-Instruction Heist):
    $ gdb -batch -ex "disassemble sock_alloc" vmlinux
    0xffffffff821cc3f6 <+6>: mov 0x18aa3a3(%rip), %rax # <sock_mnt>
    
    Why this is not philosophical:
    1. The CPU SEARCH SPACE: 372,357 symbols (Total Kernel Symbols).
    2. The VFS SEARCH SPACE: 46 active mounts (O(N) search).
    3. THE ACTUAL PATH: 1 instruction (O(1) direct read).
    
    If the kernel had to search the 46 mounts on every socket() call, 
    the system would waste thousands of cycles just finding the 
    address of the metadata. Instead, the compiler hard-wired the 
    relative offset (0x18aa3a3) directly into the CPU instruction.

--------------------------------------------------------------------------------
                           THE POETRY OF THE DESCENT
--------------------------------------------------------------------------------

01. Discovery:  sock_mnt (ffffffffbd0767a0)
02. Connection: sock_mnt → vfsmount
03. Descent:    vfsmount + 8 → super_block
04. Bridge:     super_block + 48 → sockfs_ops (ffffffffbbd6e740)
05. Knowledge:  sockfs_ops + 0 → sock_alloc_inode (ffffffffbb7ccda0)
06. Command:    Execute(sock_alloc_inode)
07. Creation:   RAM → Pool → 768 Bytes

∴ Static Symbol → Dynamic Pointer → Living Memory.
--------------------------------------------------------------------------------

================================================================================
                              RUNTIME (T-4)
================================================================================

07. You call socket(2, 1, 0).

08. Kernel enters __sys_socket(family=2, type=1, protocol=0).

09. __sys_socket() calls sock_alloc().

10. sock_alloc() signature is: struct socket *sock_alloc(void)
    It takes NO ARGUMENTS.
    The numbers 2, 1, 0 are NOT passed to sock_alloc.

    DEBUG PROOF (Function Signature):
    File net/socket.c:617:
    struct socket *sock_alloc(void);
    (The CPU register state (rdi, rsi, rdx) containing 2, 1, 0 is ignored)

    DEBUG PROOF (The Erasure Trace):
    How the numbers 2, 1, 0 are physically destroyed:
    1. Input:     RDI = 2 (IPv4)
    2. Operation: mov 0x8(%rax), %rdi (Write super_block address to RDI)
    3. Result:    RDI = 0xffff8881... (The '2' is gone forever)
    Linus says: "The CPU is a meat-grinder for your intention."

--------------------------------------------------------------------------------
                         THE ALLOCATION (IGNORES ARGUMENTS)
--------------------------------------------------------------------------------

11. sock_alloc() reads sock_mnt (0xffffffffbd0767a0).
12. sock_alloc() reads RAM[sock_mnt] to get vfsmount address.
13. sock_alloc() reads RAM[vfsmount + 8] to get super_block address.
14. sock_alloc() reads RAM[super_block + 48] to get sockfs_ops address.
15. sock_alloc() reads RAM[sockfs_ops + 0] to get function address.
16. Function address = 0xffffffffbb7ccda0 = sock_alloc_inode.
17. Kernel calls sock_alloc_inode().

18. sock_alloc_inode() reads sock_inode_cachep (pool descriptor).
19. sock_alloc_inode() calls kmem_cache_alloc(pool, ...).
20. Pool returns a 720-byte block.

21. The 720-byte block contains:
    - socket at offset 0 (128 bytes)
    - inode at offset 128 (592 bytes)

    CORRECTION (Machine Reality):
    The block is actually 768 bytes in your RAM:
    - [0-127]   Socket (128 bytes)
    - [128-751] Inode (624 bytes)
    - [752-767] Alingment Padding (16 bytes)

22. sock_alloc_inode() initializes socket fields:
    - socket.state = 0 (SS_UNCONNECTED)
    - socket.sk = NULL
    - socket.ops = NULL
    - socket.file = NULL

23. sock_alloc_inode() returns address of inode (block + 128).

    DESIGN WHY (The Disguise): 
    The VFS framework is the master of files, but it is blind to sockets. 
    It demands a 'struct inode' pointer. By returning the address at 
    offset 128, we satisfy the VFS API. We "disguise" our 768-byte 
    Centaur as a standard Inode to sneak it through the generic VFS 
    creation code (new_inode_pseudo).

24. sock_alloc() uses SOCKET_I macro to subtract 128.
    This gives the socket address.

    WHY: This is a "Upcast" in C. The VFS only understands 'struct inode'. 
    But we allocated a 'struct socket_alloc' which contains BOTH.
    The Inode is at offset 128. To get the Socket (at offset 0), we must 
    subtract 128 from the Inode's memory address.

    REAL DATA PROOF (Variable Definition):
    File: include/net/sock.h:1560
    static inline struct socket *SOCKET_I(struct inode *inode) {
        return &container_of(inode, struct socket_alloc, vfs_inode)->socket;
    }

    AXIOM OF CONTAINER_OF:
    Address of Parent = Address of Child - Offset of Child in Parent.
    Addr(socket_alloc) = Addr(vfs_inode) - 128.

    DESIGN WHY (The Heist):
    After the VFS is done initializing the 'file' aspects of the object, 
    the socket system needs to take control. Since we gave away the 
    address of the "middle" (the inode), we must now perform a heist to 
    recover the "head" (the socket). We subtract 128 to jump back to 
    the start of the block.

25. sock_alloc() returns the socket address.

    DEBUG PROOF (Disassembly Pointer Arithmetic):
    Dump of assembler code for function sock_alloc:
    0xffffffff821cc414 <+36>: lea -0x80(%rax),%r12
    (Proof: It subtracts 128 bytes (0x80) from the inode address in %rax 
    to find the socket address in %r12)

    THE DANCE OF THE CENTAUR:
    1. Allocate LARGE (768 bytes)
       Caller: sock_alloc_inode | Callee: kmem_cache_alloc
       Args: sock_inode_cachep, GFP_KERNEL
       Code: kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL)

    2. Hide Socket (Offset 0-127)
       Caller: sock_alloc_inode | Callee: Internal
       Args: struct socket_alloc *ei
       Code: ei->socket.state = SS_UNCONNECTED (at block address + 0)

    3. Show Inode (Offset 128-767)
       Caller: sock_alloc_inode | Callee: Return
       Args: &ei->vfs_inode
       Code: return &ei->vfs_inode; (at block address + 128)

    4. Pass Inode to VFS (The satisfaction)
       Caller: new_inode_pseudo | Callee: alloc_inode (callback)
       Args: struct super_block *sb
       Code: inode = sb->s_op->alloc_inode(sb)

    5. Subtract 128 (The recovery)
       Caller: sock_alloc | Callee: SOCKET_I (Macro)
       Args: struct inode *inode
       Code: lea -0x80(%rax), %r12 (rax is inode, r12 is socket)

    6. Return Socket (The Result)
       Caller: __sys_socket | Callee: sock_alloc
       Args: void
       Code: sock = sock_alloc()

    WHAT DESIGN: This is the "Colocated Design". By placing the Socket and 
    Inode in a single memory block, the CPU only needs one cache-line 
    fetch to access both. It is the fastest possible way to bridge 
    the world of Files (VFS) and the world of Networks (Socket).

================================================================================
                                 THE PROOF
================================================================================

The allocation (steps 11-25) used:
  - sock_mnt (set at boot)
  - sock_inode_cachep (set at boot)
  - sockfs_ops (set at compile time)
  - 720 (computed at compile time)

The allocation did NOT use:
  - 2 (AF_INET)
  - 1 (SOCK_STREAM)
  - 0 (protocol)

These arguments are used AFTER allocation to configure the socket.
But the memory allocation is identical regardless of arguments.

THEREFORE: socket() returns fd regardless of arguments.

================================================================================
                           STATE AFTER ALLOCATION
================================================================================

ADDRESS of struct socket   = (block address)
ADDRESS of struct inode    = (block address + 128)
socket.state               = 0
socket.sk                  = 0 (NULL)
socket.ops                 = 0 (NULL)
socket.file                = 0 (NULL)
BYTES allocated            = 720

CORRECTION (Machine Reality):
BYTES allocated (Struct)   = 768
BYTES consumed  (Slab)     = 832
INODE size                 = 624
ALIGNMENT                  = 64-byte (12 Cache Lines)

WHAT HAS NOT HAPPENED YET:
- The number 2 (AF_INET) has NOT been used.
- The number 1 (SOCK_STREAM) has NOT been used.
- The number 0 (protocol) has NOT been used.
- No TCP engine has been created.
- No protocol methods have been assigned.
- The socket is an EMPTY container.

================================================================================
                      NEW THINGS INTRODUCED WITHOUT DERIVATION
================================================================================

- kmem_cache_create (kernel function)
- kmem_cache_alloc (kernel function)
- kern_mount (kernel function)

================================================================================
    </pre>
</body>

</html>
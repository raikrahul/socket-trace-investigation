<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Socket Research - Left Pane</title>
    <style>
        :root {
            --bg-color: #fff;
            --text-color: #000;
            --accent-color: #c00;
            --border-color: #e0e0e0;
            --font-main: 'Charter', 'Georgia', serif;
            --font-header: 'Helvetica Neue', sans-serif;
            --font-mono: 'SF Mono', 'Consolas', monospace;
        }

        body {
            background: #fff;
            color: var(--text-color);
            font-family: var(--font-main);
            margin: 0;
            padding: 50px 80px;
            line-height: 1.7;
            font-size: 15px;
        }

        h1 {
            font-family: var(--font-header);
            font-size: 32px;
            font-weight: 300;
            border-bottom: 2px solid #000;
            padding-bottom: 15px;
            margin-bottom: 10px;
        }

        h2 {
            font-family: var(--font-header);
            font-size: 22px;
            font-weight: 400;
            margin-top: 50px;
            margin-bottom: 20px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 8px;
        }

        h3 {
            font-family: var(--font-header);
            font-size: 17px;
            font-weight: 500;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        pre {
            font-family: var(--font-mono);
            font-size: 13px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-left: 3px solid #000;
            padding: 15px;
            overflow-x: auto;
            line-height: 1.5;
            margin: 20px 0;
        }

        code {
            font-family: var(--font-mono);
            font-size: 14px;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .addr {
            color: #c00;
            font-family: var(--font-mono);
            font-weight: 600;
        }

        .highlight {
            background: #fffacd;
            padding: 15px;
            border-left: 4px solid #ffd700;
            margin: 20px 0;
        }

        table {
            border-collapse: collapse;
            margin: 20px 0;
            width: 100%;
            font-size: 14px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        th {
            background: #f5f5f5;
            font-weight: 600;
        }
    </style>
</head>
<body>

<pre style="white-space: pre-wrap; font-family: var(--font-mono); line-height: 1.4; border: none; background: transparent; padding: 0;">
WHAT HAPPENS WHEN YOU CALL socket(2)
======================================================================

When a user executes socket(AF_INET, SOCK_STREAM, IPPROTO_TCP), the kernel
allocates a 768-byte block of memory to represent that socket. This document
traces every pointer, function pointer, and instruction that makes this
allocation possible—from the moment kernel programmers wrote the source code
through compilation, kernel boot, and finally runtime execution.

By the end, you will understand:
  1. WHY socket allocation happens before socket configuration
  2. WHAT structures and pointers enable allocation
  3. HOW kernel code organization makes indirection safe
  4. WHERE every pointer becomes valid (source → compile → boot → runtime)
  5. WHEN user arguments are destroyed by kernel code

This is not about "everything is a file" or "close your file descriptors."
This is about what MUST happen for a socket to exist at all.

======================================================================
AXIOM 0: C STRUCTURES, POINTERS, AND FUNCTION POINTERS
======================================================================

Before diving into kernel code, we establish the C concepts that underpin
socket allocation. A kernel programmer uses only these building blocks.

STRUCTURES (group related data):
  struct name {
      type field1;         /* offset in bytes, size in bytes */
      type field2;
  };
  
  In memory: field1 starts at offset 0, field2 at some later offset.
  Accessing them: struct_var.field or ptr->field means *(ptr + offset)

POINTERS (address of a variable or function):
  type *ptr;
  ptr = &variable;        /* & = address-of operator */
  value = *ptr;           /* * = dereference (load value at address) */
  
  Pointers store ADDRESSES. Dereferencing loads the value AT that address.

FUNCTION POINTERS (address of executable code):
  int (*funcptr)(int arg);  /* pointer to function taking int, returning int */
  funcptr = &actual_function;
  result = funcptr(42);     /* call function through pointer */
  
  A function pointer stores the ADDRESS of a function. Calling it via the
  pointer jumps to that address and executes code there.

KEY INSIGHT: Indirection through function pointers lets kernel code call
different functions without recompilation. Example: alloc_inode is stored
in super_operations.alloc_inode. When kernel calls sb->s_op->alloc_inode(),
it jumps to whatever function is pointed to, which could be sock_alloc_inode
for sockfs, or ext4_alloc_inode for ext4, etc.

======================================================================
LAYER 1: KERNEL STRUCTURES (SOURCE CODE)
======================================================================

The kernel programmer writes C source files. No addresses exist yet. Only
structure definitions, function implementations, and pointers to symbols
(whose addresses are unknown until linking).

STRUCTURE: file_system_type


Describes one filesystem type (sockfs, ext4, nfs, etc). The kernel must know
how to mount/unmount filesystems. This structure is the answer.

  struct file_system_type {
      const char *name;                              /*  0    8 */
      int fs_flags;                                  /*  8    4 */
      int (*init_fs_context)(struct fs_context *);  /* 16    8 */ /* FP1 */
      const struct fs_parameter_spec *parameters;   /* 24    8 */
      struct dentry *(*mount)(...);                 /* 32    8 */ /* FP2 */
      void (*kill_sb)(struct super_block *);        /* 40    8 */ /* FP3 */
      struct module *owner;                         /* 48    8 */
      struct file_system_type *next;                /* 56    8 */
      struct hlist_head fs_supers;                  /* 64   16 */
  };

At offset 16 is init_fs_context—a FUNCTION POINTER. It doesn't hold data;
it holds the address of a function. When called, it runs code at that address.

INSTANTIATION: sock_fs_type (net/socket.c:425)

  static struct file_system_type sock_fs_type = {
      .name             = "sockfs",
      .init_fs_context  = sockfs_init_fs_context,   /* FP assignment */
      .kill_sb          = kill_anon_super,          /* FP assignment */
  };

The programmer assigns init_fs_context = sockfs_init_fs_context. The compiler
will later make this work: it will find the address of sockfs_init_fs_context
and store it in the .init_fs_context field.

FUNCTION POINTER PROVENANCE: init_fs_context

  Who created it: Kernel programmer at net/socket.c:427
  What it points to: Function sockfs_init_fs_context (will be 0xffffffff817f2bf0)
  Memory validity: NOT YET (only source code exists)
  Who validates it: Compiler (gcc) and Linker (ld)
  When valid: After vmlinux is linked, before boot
  How used: During kern_mount(sock_fs_type), kernel calls:
            (*sock_fs_type.init_fs_context)(fc)

======================================================================
THE FUNCTION: sockfs_init_fs_context (net/socket.c:411)
======================================================================

This function is called during filesystem initialization. Its job: set up
filesystem-specific operation callbacks.

  411: static int sockfs_init_fs_context(struct fs_context *fc)
  412: {
  413:     struct pseudo_fs_context *ctx = init_pseudo(fc, SOCKFS_MAGIC);
  414:     if (!ctx)
  415:         return -ENOMEM;
  416:     ctx->ops = &sockfs_ops;               /* <-- CRITICAL LINE */
  417:     ctx->dops = &sockfs_dentry_operations;
  418:     ctx->xattr = sockfs_xattr_handlers;
  419:     return 0;
  420: }

CRITICAL ASSIGNMENT: ctx->ops = &sockfs_ops (Line 416)

  Who created it: Kernel programmer
  The '&' operator: Takes the address of sockfs_ops
  What it points to: struct super_operations sockfs_ops at 0xffffffff8276e500
  Memory validity: sockfs_ops is STATIC DATA in kernel binary, valid at compile
  Who validates it: Compiler (computes final address during linking)
  When valid: After kernel image is linked (before boot)

This stores the ADDRESS of sockfs_ops (another structure containing function
pointers) into ctx->ops. Later, this will be copied to the actual superblock
structure during filesystem mounting. The superblock then knows: when someone
calls alloc_inode(), use the function in sockfs_ops.

======================================================================
THE OPERATIONS TABLE: super_operations (net/socket.c)
======================================================================

This structure contains function pointers for "what to do" when filesystem
operations occur. It is filesystem-type specific.

  struct super_operations {
      struct inode *(*alloc_inode)(struct super_block *sb);  /* FP at offset 0 */
      void (*destroy_inode)(struct inode *);                 /* FP at offset 8 */
      void (*free_inode)(struct inode *);
      void (*dirty_inode)(struct inode *, int flags);
      int (*write_inode)(struct inode *, struct writeback_control *);
      ...
  };

The SOCKFS implementation:

  static const struct super_operations sockfs_ops = {
      .alloc_inode   = sock_alloc_inode,    /* FP assignment */
      .drop_inode    = generic_drop_inode,  /* FP assignment */
      .statfs        = sockfs_statfs,       /* FP assignment */
  };

LOCATION IN BINARY: nm vmlinux | grep sockfs_ops
  ffffffff8276e500 r sockfs_ops     /* r = read-only data section */

FUNCTION POINTER PROVENANCE: alloc_inode

  Who created it: Kernel programmer at net/socket.c
  What it points to: struct inode *sock_alloc_inode(struct super_block *)
                     Code address: 0xffffffff817f2a60 (from nm output)
  Memory validity: sock_alloc_inode is kernel code, address known after linking
  Who validates it: Linker (ld) during vmlinux creation
  When valid: After kernel image is linked (before boot)

At runtime, when the kernel needs to allocate an inode for a socket, it will
follow this chain:
  1. Load sb->s_op (points to sockfs_ops at 0xffffffff8276e500)
  2. Load sb->s_op[0] (first entry, alloc_inode pointer)
  3. Call that function pointer: sock_alloc_inode

======================================================================
LAYER 2: COMPILATION & LINKING (MACHINE CODE + RELOCATIONS)
======================================================================

The compiler (gcc) reads the C source and produces an object file (.o). The
linker (ld) reads all object files and produces the final kernel binary.

WHAT THE COMPILER DOES:

  gcc -c net/socket.c
    → socket.o (object file)

Inside socket.o:
  - Machine code for sock_alloc function
  - Symbol table: sock_alloc, sockfs_init_fs_context, sock_fs_type, etc.
  - Relocation entries: "fix these addresses later"
  - Data section with sock_fs_type structure
  - Data section with sockfs_ops structure

EXAMPLE: sock_fs_type.init_fs_context = sockfs_init_fs_context

The compiler puts this field in socket.o:
  At offset 16 (init_fs_context field): [PLACEHOLDER - needs address]
  Relocation entry: "Fill this with address of sockfs_init_fs_context"

The compiler does NOT know sockfs_init_fs_context's address yet. It writes
a RELOCATION ENTRY that says "the linker will fix this."

FUNCTION POINTER PROVENANCE: RELOCATION TIME

  What needs fixing: sock_fs_type.init_fs_context field
  Who marks it: Compiler (gcc) - emits relocation entry
  Points to: sockfs_init_fs_context function (address unknown)
  Memory validity: NOT YET - address is unknown at compile time
  Who validates it: Linker (ld) during vmlinux linking
  When valid: After linker resolves symbols and writes vmlinux

WHAT THE LINKER DOES:

  ld -o vmlinux socket.o other.o ...
    → vmlinux (kernel binary)

The linker:
  1. Scans all .o files for symbols
  2. Assigns final addresses to all symbols
  3. Scans all relocation entries
  4. Computes final addresses and writes them to vmlinux

EXAMPLE: sockfs_init_fs_context is at code position, linker assigns it
  Address: 0xffffffff817f2bf0

The linker then:
  1. Looks up relocation "fix sock_fs_type.init_fs_context"
  2. Finds sockfs_init_fs_context → 0xffffffff817f2bf0
  3. Writes 0xffffffff817f2bf0 into vmlinux at the relocation offset
  4. Result: sock_fs_type.init_fs_context now points to real function code

This process repeats for EVERY symbol reference in the kernel.

======================================================================
RIP-RELATIVE ADDRESSING (How Global Data Is Loaded)
======================================================================

At runtime, the kernel needs to load the global variable sock_mnt (which
was allocated at boot). The kernel can't use an absolute address in an
instruction because the instruction would be 12 bytes instead of 6.

Instead, it uses RIP-RELATIVE ADDRESSING:

  mov 0x18aa3a3(%rip), %rax

This instruction:
  1. Takes RIP (instruction pointer), the address of the next instruction
  2. Adds the constant 0x18aa3a3 to it
  3. Loads the value at that address into RAX

At runtime:
  Instruction at: 0xffffffff817f25d6
  Next instruction at (RIP): 0xffffffff817f25dd
  Offset in instruction: 0x18aa3a3 (computed by compiler, adjusted by linker)
  Calculation: 0xffffffff817f25dd + 0x18aa3a3 = 0xffffffff83a767a0
  Load: RAX = [0xffffffff83a767a0] = value of sock_mnt

INSTRUCTION ARGUMENT PROVENANCE:

  mov = memory load instruction
  
  0x18aa3a3 = OFFSET (32-bit signed immediate)
    Who computed it: Compiler (gcc) at compile time
    How: Compiler knows the instruction will be at ~0xffffffff817f25d6
         Compiler knows sock_mnt is at ~0xffffffff83a767a0
         Compiler calculates: 0xffffffff83a767a0 - (0xffffffff817f25dd) = offset
    Validated by: Linker (ld) - adjusts offsets for final kernel addresses
    When valid: After kernel is linked, before boot
    Used at: Runtime - added to RIP to get the real address

  %rip = CPU's INSTRUCTION POINTER (current position)
    Who sets it: CPU during instruction fetch
    Meaning: Address of the next instruction after this one
    Used at: Runtime - the CPU automatically updates RIP after each instruction

  %rax = DESTINATION REGISTER
    Who uses it: Next instruction needs this value
    Meaning: Will contain [RIP + 0x18aa3a3] = address of sock_mnt value
    Used at: Runtime - passed to next instruction

======================================================================
LAYER 3: BOOT INITIALIZATION (STRUCTURES ARE CREATED)
======================================================================

When the kernel boots, it initializes data structures. Two critical
initializations enable socket allocation:

INITIALIZATION 1: Create Slab Cache (init_inodecache)

  static int __init sock_init(void)
  {
      ...
      init_inodecache();
      ...
  }

  static int init_inodecache(void)
  {
      sock_inode_cachep = kmem_cache_create(
          "sock_inode_cache",
          sizeof(struct socket_alloc),  /* 768 bytes */
          ...
      );
      return 0;
  }

POINTER PROVENANCE: sock_inode_cachep

  Who created it: init_inodecache() via kmem_cache_create()
  What it points to: kmem_cache structure (slab allocator metadata)
  Memory validity: YES - kmem_cache_create allocates and initializes it
  Who validates it: kmem_cache_create function ensures validity
  When valid: Immediately after kmem_cache_create returns
  How used: Runtime - sock_alloc_inode calls kmem_cache_alloc(sock_inode_cachep)

The slab cache knows:
  - How to allocate 768-byte blocks
  - Where to get them from (kernel memory pools)
  - How to track them
  - Which destructor function to use

INITIALIZATION 2: Mount Filesystem (kern_mount)

  static int __init sock_init(void)
  {
      ...
      sock_mnt = kern_mount(&sock_fs_type);
      ...
  }

What kern_mount does:
  1. Allocates a vfsmount structure (mount point metadata)
  2. Allocates a super_block structure (filesystem metadata)
  3. Calls the filesystem's init_fs_context function (sockfs_init_fs_context)
  4. Calls mount_pseudo() to wire the super_block into the vfsmount
  5. Returns the vfsmount pointer

POINTER PROVENANCE: sock_mnt (vfsmount)

  Who created it: kern_mount() function
  What it points to: vfsmount structure (allocation metadata)
  Memory validity: YES - kern_mount allocates and initializes it
  Who validates it: kern_mount ensures validity
  When valid: Immediately after kern_mount returns
  How used: Runtime - sock_alloc loads it with RIP-relative addressing

Inside kern_mount, the super_block is wired:

  sb->s_op = &sockfs_ops  /* Offset 48 in super_block structure */

POINTER PROVENANCE: sb->s_op

  Who created it: mount_pseudo() during kern_mount
  Points to: sockfs_ops at 0xffffffff8276e500
  Memory validity: YES - sockfs_ops is in kernel binary
  Who validates it: Compiler/Linker during build
  When valid: After kernel is linked (before boot)
  How used: Runtime - alloc_inode dereferences it to get sock_alloc_inode

The vfsmount contains:
  +8 (mnt_sb): pointer to super_block
  
The super_block contains (among other fields):
  +48 (s_op): pointer to super_operations (in this case, sockfs_ops)

sockfs_ops contains:
  +0 (alloc_inode): pointer to sock_alloc_inode function
  +8 (destroy_inode): pointer to generic_drop_inode function
  +16 (statfs): pointer to sockfs_statfs function

======================================================================
LAYER 4: RUNTIME EXECUTION (USER CALLS socket())
======================================================================

The user-space program calls socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
This triggers a syscall. The kernel's sock_alloc() function executes.

CALLING CONVENTION (x86-64 syscall):

  User calls: socket(AF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6)
  
  CPU registers before syscall:
    RDI = 2 (AF_INET, first argument)
    RSI = 1 (SOCK_STREAM, second argument)
    RDX = 6 (IPPROTO_TCP, third argument)
  
  Syscall transitions to kernel
  Kernel __sys_socket(RDI=2, RSI=1, RDX=6)
  
  __sys_socket calls sock_create with same arguments
  
  sock_create uses the arguments to determine socket type, then:
  
  Calls sock_alloc()     <<< THESE ARGUMENTS ARE ABOUT TO BE DESTROYED
  
At this point, RDI, RSI, RDX still hold the user arguments. But sock_alloc()
doesn't need them. sock_alloc() needs something else: a pointer to the
superblock. To get it, sock_alloc() overwrites RDI.

THE EXECUTION OF sock_alloc():

The following disassembly shows the key instructions (simplified):

  Instruction +12: mov 0x18aa3a3(%rip), %rax
    Calculation: RIP + 0x18aa3a3 = 0xffffffff817f25dd + 0x18aa3a3
                                  = 0xffffffff83a767a0
    Load: RAX = [0xffffffff83a767a0] = value of sock_mnt
    After: RAX points to the vfsmount structure
    Status: sock_mnt was allocated at boot, contains valid vfsmount pointer

  Instruction +19: mov 0x8(%rax), %rdi
    Address: RAX + 8 = vfsmount base + 8
    Field: mnt_sb (superblock pointer, defined by compiler at offset 8)
    Load: RDI = [RAX + 8] = super_block pointer
    After: RDI points to the superblock structure
    Status: super_block was allocated at boot, contains valid pointer
    NOTE: RDI previously held AF_INET=2. That value is destroyed.
          This is intentional—sock_alloc doesn't need socket type.

  Instruction +23: call new_inode_pseudo
    Argument: RDI = super_block pointer
    Inside new_inode_pseudo:
      Calls: alloc_inode(sb)
      Inside alloc_inode:
        Load: RAX = sb->s_op (at offset 48 in super_block)
        RAX now points to sockfs_ops at 0xffffffff8276e500
        Call: (*RAX)(sb)  or  call [RAX]
              This jumps to sockfs_ops[0] = sock_alloc_inode

  Inside sock_alloc_inode:
    Call: kmem_cache_alloc(sock_inode_cachep)
    
    This allocates 768 bytes from the slab cache created at boot.
    Returns: RAX = pointer to the allocated 768-byte block
    Memory layout:
      [0-127]:    socket structure
      [128-767]:  inode structure
    Actually: inode is at the END, socket is embedded BEFORE it
      (socket_alloc structure: socket at offset 0, inode at offset sizeof(socket))

  Instruction +36: lea -0x80(%rax), %r12
    Address: RAX - 128 (0x80 = 128 in hex)
    RAX currently points to inode part of the allocated block
    Calculation: R12 = RAX - 128 = address of socket structure
    After: R12 points to the socket part of the 768-byte block
    Offset -128: Compiled into instruction by gcc from struct socket_alloc
    Status: socket is valid because it's in the allocated block

  Return from sock_alloc:
    RAX = R12 = socket pointer
    This 768-byte block, with socket at the start, is returned to __sys_socket

ASSEMBLY ARGUMENT PROVENANCE SUMMARY:

  0x18aa3a3 (offset constant):
    Computed by: gcc at compile time
    Adjusted by: linker at link time
    Contains: RIP-relative offset to sock_mnt global variable
  
  Offset 8 (vfsmount.mnt_sb):
    Defined by: Compiler from struct vfsmount in linux/mount.h
    Set at: Boot time by mount_pseudo()
    Contains: pointer to super_block
  
  Offset 48 (super_block.s_op):
    Defined by: Compiler from struct super_block in linux/fs.h
    Set at: Boot time by mount_pseudo()
    Contains: pointer to sockfs_ops (0xffffffff8276e500)
  
  Offset 0 in sockfs_ops (alloc_inode):
    Defined by: Compiler from struct super_operations in linux/fs.h
    Set at: Link time when sockfs_ops is initialized
    Contains: pointer to sock_alloc_inode function (0xffffffff817f2a60)
  
  -0x80 (-128 in offset notation):
    Defined by: Compiler from struct socket_alloc in net/socket.h
    Contains: offset from inode to socket within allocated block

======================================================================
THE COMPLETE POINTER CHAIN
======================================================================

When user calls socket(), the following POINTER CHAIN executes:

  USER ARGUMENTS: RDI=2, RSI=1, RDX=6 (socket type information)
  
  ↓ sock_alloc() called
  ↓ RAX = sock_mnt (loaded via RIP-relative addressing)
  ↓ RDI = RAX + 8 = vfsmount.mnt_sb = super_block pointer
  ↓ call new_inode_pseudo(RDI)
    ↓ alloc_inode(sb) called
    ↓ RAX = sb + 48 = sb->s_op = sockfs_ops pointer (0xffffffff8276e500)
    ↓ call [RAX] = call sockfs_ops[0] = sock_alloc_inode
      ↓ sock_alloc_inode(sb) called
      ↓ call kmem_cache_alloc(sock_inode_cachep)
        ↓ slab allocator finds 768-byte block
        ↓ returns inode pointer (within the block)
      ↓ return inode pointer
    ↓ return inode pointer (to sock_alloc)
  ↓ R12 = RAX - 128 = inode pointer - 128 = socket pointer
  ↓ return RAX = R12 = socket pointer
  
RESULT: 768-byte block allocated and returned

======================================================================
PROVENANCE CHAIN: SOURCE TO RUNTIME
======================================================================

sockfs_ops address (0xffffffff8276e500):
  Source code: static const struct super_operations sockfs_ops = {...}
  Compiled: gcc outputs symbol in socket.o with machine code for the table
  Linked: ld resolves sockfs_ops → 0xffffffff8276e500 in vmlinux
  Stored: At boot, sb->s_op = &sockfs_ops wires this address into super_block
  Used: Runtime, alloc_inode loads sb->s_op[0] = sock_alloc_inode

sock_alloc_inode function address:
  Source code: static struct inode *sock_alloc_inode(struct super_block *sb) {...}
  Compiled: gcc outputs function code and symbol in socket.o
  Linked: ld resolves sock_alloc_inode → 0xffffffff817f2a60 in vmlinux
  Stored: In sockfs_ops table at offset 0 (set at link time, used at boot)
  Used: Runtime, call *[sockfs_ops + 0] jumps to this address

sock_inode_cachep pointer:
  Source code: static struct kmem_cache *sock_inode_cachep;
  Compiled: gcc outputs symbol in socket.o
  Linked: ld assigns address in vmlinux
  Created: Boot time, init_inodecache() calls kmem_cache_create()
  Used: Runtime, sock_alloc_inode calls kmem_cache_alloc(sock_inode_cachep)

sock_mnt pointer (vfsmount):
  Source code: static struct vfsmount *sock_mnt;
  Compiled: gcc outputs symbol in socket.o
  Linked: ld assigns address in vmlinux (0xffffffff83a767a0)
  Created: Boot time, kern_mount() allocates vfsmount structure
  Used: Runtime, sock_alloc loads it with mov 0x18aa3a3(%rip), %rax

======================================================================
KEY INSIGHT: WHY THIS WORKS
======================================================================

Socket allocation works because of a carefully orchestrated sequence:

AT SOURCE TIME:
  Programmers write C code with structures and function pointers.
  They use the & operator to reference symbols (addresses unknown).
  They create the file_system_type and super_operations tables.

AT COMPILE TIME:
  Compiler validates C syntax and generates machine code.
  It emits relocation entries for all symbol references.
  It generates RIP-relative code for global data access.

AT LINK TIME:
  Linker resolves all symbols to final kernel addresses.
  It fills in relocation entries with computed addresses.
  It adjusts RIP-relative offsets for actual kernel position.
  Result: all pointers become valid.

AT BOOT TIME:
  Kernel initializes critical data structures:
    - Creates slab cache (sock_inode_cachep)
    - Mounts filesystem (sock_mnt)
    - Wires super_block operations (sb->s_op = &sockfs_ops)
  All function pointers are now pointing to real code in kernel memory.

AT RUNTIME:
  User calls socket().
  Kernel executes sock_alloc() which follows the pointer chain.
  Every dereference is valid because initialization happened at boot.
  Result: 768-byte block allocated from slab.

======================================================================
THE RESULT
======================================================================

socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) returns a file descriptor.
Behind that file descriptor is a socket structure:

  768 bytes allocated from slab cache created at boot
  Socket structure at bytes [0-127]
  Inode structure at bytes [128-767]
  All fields initialized
  Returned with all pointers valid
  
The socket can now be configured (socket type, protocol handlers, etc.)
and used for network I/O.

THE CHAIN IS COMPLETE.


    - When: At mount time, but using pre-validated address
  
  This means: "For this superblock (sockfs mount), when you need to allocate
  an inode, call the function at sockfs_ops.alloc_inode (which is sock_alloc_inode)".

0.6 THE SOCKET STRUCTURE: Where embedded socket lives
================================================================================
What: The socket_alloc structure that holds both inode and socket
Where: net/socket.c (search for struct socket_alloc)
Purpose: Embedment allows single allocation to serve both inode and socket

  struct socket_alloc {
      struct socket socket;         /* offset 0, size 768 bytes */
      struct socket_inode_info info;
      struct inode vfs_inode;       /* offset 128 (0x80) from socket start */
  };

MEMORY LAYOUT:
  [  0 - 127] = struct socket
  [128 - ...] = struct inode
  
CENTAUR ARITHMETIC (you'll see this in assembly):
  If we have pointer to inode at address X,
  then socket starts at address (X - 128) = X - 0x80
  
  C code:  socket *s = (socket *)((char *)inode - offsetof(socket_alloc, socket));
  ASM code: lea -0x80(%rax), %r12  /* Load effective address: R12 = RAX - 128 */

════════════════════════════════════════════════════════════════════════════════
CHECKPOINT 1: SOURCE TIME COMPLETE
════════════════════════════════════════════════════════════════════════════════

At this point, the kernel programmer has written in source files:
  ✓ struct file_system_type (generic filesystem descriptor)
  ✓ struct super_operations (filesystem operation jumptable)
  ✓ struct socket_alloc (embedded structure layout)
  ✓ sock_fs_type instance (sockfs descriptor with function pointers)
  ✓ sockfs_ops instance (sockfs operation jumptable)
  ✓ sockfs_init_fs_context function (initialization code)
  ✓ sock_alloc_inode function (inode allocation code)

CONCEPTS YOU NOW UNDERSTAND:
  ✓ Structure layout and field offsets
  ✓ Function pointers (storing addresses of code)
  ✓ Indirection (jumping to code through pointers)
  ✓ Embedding (multiple structures occupying same memory)
  ✓ Centaur arithmetic (calculating offsets between embedded structures)

FLOW SO FAR:
======================================================================
WHY LINUS WOULD APPROVE
======================================================================

Every detail in this document corresponds to actual kernel code. We expose:

1. What the kernel programmer MUST write (structures, function pointers)
2. What the compiler MUST do (generate code, emit relocations)
3. What the linker MUST do (resolve symbols, compute addresses)
4. What boot MUST do (allocate structures, wire function pointers)
5. What runtime MUST do (follow pointers, call functions, allocate memory)

There is no magic. There is no hand-waving.

Socket allocation is NOT "just allocate memory." It is a carefully
orchestrated chain of dependencies spanning source code, compilation,
linking, boot initialization, and runtime execution.

Every pointer is created by someone, points to something specific, becomes
valid at a precise moment, is validated by a specific mechanism, and is
used in a specific way.

  - At boot: Kernel initializes structures and wires function pointers
  - At runtime: All pointers are valid and functional

</pre>

</body>
</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Socket Proof: Machine Data</title>
  <style>
    body {
      background: #0a0a0a;
      color: #0f0;
      font-family: monospace;
      font-size: 12px;
      line-height: 1.5;
      padding: 30px;
    }

    pre {
      white-space: pre-wrap;
      margin: 0;
    }

    .cmd {
      color: #888;
    }

    .addr {
      color: #ff0;
      font-weight: bold;
    }

    .val {
      color: #0ff;
    }
  </style>
</head>

<body>
  <pre>
================================================================================
                    MACHINE DATA: REAL ADDRESSES FROM YOUR KERNEL
================================================================================

FETCHED: 2026-01-22 21:01
KERNEL:  6.14.0-37-generic
COMPILED: Thu Nov 20 10:25:38 UTC 2024
BOOT:    2026-01-22 09:54:41
SOCKETS: 1325 currently active

================================================================================
SECTION 0: BINARY PROOF (T-0) - Hardcoded in the vmlinux file
================================================================================

AXIOMATIC ORIGIN OF NAMES:
The kernel has millions of symbols. We track these two because they anchor
the Sockets to the Filesystem:
1. sockfs_ops:      The operational callback table for the sockfs filesystem.
2. sock_alloc_inode: The specific function that creates the 768-byte centaur.

How do we prove the address was decided at compile time (T-0)?
We look at the kernel binary file before it is ever loaded into RAM.

<span class="cmd">$ nm /usr/lib/debug/boot/vmlinux-$(uname -r) | grep sockfs_ops</span>
<span class="addr">ffffffff8276e740</span> d sockfs_ops

SECTION 0B: TYPE AND SCOPE PROOF (T-0)
================================================================================

How do we prove the header include chain?
$ grep -E "#include <linux/net.h>|#include <linux/fs.h>" /usr/src/linux-source-*/net/socket.c
#include <linux/net.h>
(Truth: socket.c includes net.h, which includes fs.h where struct super_operations is defined.)

How do we prove fs.h is the VFS?
$ grep "VFS" /usr/src/linux-source-*/include/linux/fs.h | head -n 3
- struct vfsmount;
- struct mutex s_vfs_rename_mutex;
- "attributes that the VFS layer can..."
(Truth: The term "VFS" is the logical alias for the interfaces in fs.h.)

How do we prove it is "static"?
$ nm /usr/lib/debug/boot/vmlinux-$(uname -r) | grep " d sockfs_ops"
ffffffff8276e740 d sockfs_ops
(Truth: The "d" symbol type (lowercase) in nm output proves it has INTERNALLY 
scoped linkage. If it were global/exported, it would be "D" (uppercase).)

The value <span class="addr">ffffffff8276e740</span> is physically stored in the ELF symbol table
of the kernel binary. This is the "Base Address" chosen by the Linker.
All searches in /proc/kallsyms originate from this hardcoded truth.

================================================================================
SECTION 1: KERNEL SYMBOL TABLE
================================================================================

<span class="cmd">$ sudo grep -E "sock_|sockfs|simple_statfs" /proc/kallsyms</span>

sock_alloc_inode      = <span class="addr">0xffffffffbb7ccda0</span>  t (text/function)
sock_free_inode       = <span class="addr">0xffffffffbb7ccd60</span>  t (text/function)
sockfs_ops            = <span class="addr">0xffffffffbbd6e740</span>  d (data/struct)
sock_inode_cachep     = <span class="addr">0xffffffffbc38bda0</span>  d (data/pointer)
sock_mnt              = <span class="addr">0xffffffffbd0767a0</span>  t (text/pointer)
simple_statfs         = <span class="addr">0xffffffffbae085d0</span>  T (exported function)

================================================================================
SECTION 1B: LINKER (System.map) VS BOOT (KASLR/kallsyms) PROOF
================================================================================

The Linker assigns base addresses (T-0). KASLR shifts them at Boot (T-2).

<span class="cmd">$ sudo grep sockfs_ops /boot/System.map-$(uname -r)</span>
Linker Address (Base): <span class="addr">0xffffffff8276e740</span>

<span class="cmd">$ sudo grep sockfs_ops /proc/kallsyms</span>
Actual Address (Boot): <span class="addr">0xffffffffbbd6e740</span>

CALCULATION:
  Actual: 0xffffffffbbd6e740
- Linker: 0xffffffff8276e740
----------------------------
  Shift:  0x0000000039600000 (KASLR Offset)

Everything moves together. The internal offsets (like s_op at 48) remain constant.

================================================================================
SECTION 2: STRUCT OFFSETS (from kernel headers)
================================================================================

struct vfsmount:
  mnt_root   @ offset 0   (8 bytes, pointer to dentry)
  mnt_sb     @ offset 8   (8 bytes, pointer to super_block)
  mnt_flags  @ offset 16  (4 bytes, int)
  mnt_idmap  @ offset 24  (8 bytes, pointer)

struct super_block:
  s_list     @ offset 0   (16 bytes, list_head)
  s_dev      @ offset 16  (4 bytes, dev_t)
  s_blocksize@ offset 24  (8 bytes, unsigned long)
  s_maxbytes @ offset 32  (8 bytes, loff_t)
  s_type     @ offset 40  (8 bytes, pointer)
  s_op       @ offset 48  (8 bytes, pointer to super_operations)

struct super_operations:
  alloc_inode @ offset 0  (8 bytes, function pointer)
  free_inode  @ offset 8  (8 bytes, function pointer)  
  statfs      @ offset 16 (8 bytes, function pointer)

struct socket_alloc:
  socket     @ offset 0   (128 bytes)
  vfs_inode  @ offset 128 (592 bytes)
  TOTAL SIZE = 720 bytes

  CORRECTION (Machine Truth):
  vfs_inode  @ offset 128 (624 bytes)
  TOTAL SIZE = 768 bytes (12 * 64-byte Cache Lines)

  HARDWARE PROOF:
  <span class="cmd">$ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</span>
  <span class="val">64</span>

  DISTRIBUTED PROOF (The Ubuntu Promise):
  <span class="cmd">$ grep "CONFIG_X86_L1_CACHE_SHIFT" /boot/config-$(uname -r)</span>
  <span class="val">CONFIG_X86_L1_CACHE_SHIFT=6</span>
  (2^6 = 64 bytes. This is the value used to compile your kernel binary.)

================================================================================
SECTION 3: THE CHAIN VERIFICATION
================================================================================

START: sock_mnt = <span class="addr">0xffffffffbd0767a0</span>

STEP 1: RAM[sock_mnt] -> vfsmount address
        (This is the vfsmount struct created by kern_mount)

STEP 2: RAM[vfsmount + 8] -> super_block address
        offset 8 = mnt_sb field

STEP 3: RAM[super_block + 48] -> super_operations address
        offset 48 = s_op field
        Result = <span class="addr">0xffffffffbbd6e740</span> (sockfs_ops)

STEP 4: RAM[sockfs_ops + 0] -> function address
        offset 0 = alloc_inode field
        Result = <span class="addr">0xffffffffbb7ccda0</span> (sock_alloc_inode)

CONCLUSION: The chain leads to sock_alloc_inode.

SECTION 3B: SEARCH SPACE ANALYSIS (DATA PROOF)
================================================================================

Total Kernel Symbols: 372,357
Active Mounts:       46

AXIOM OF INSTRUMENTS:
1. vmlinux: The debugging binary of the kernel (contains DWARF symbols).
2. gdb:     The GNU Debugger (used to disassemble live machine code).

PROOF (O(1) ASSEMBLY):
$ gdb -batch -ex "disassemble sock_alloc" vmlinux
0xffffffff821cc3f6 <+6>: mov 0x18aa3a3(%rip), %rax

Rather than searching through 46 mounts or 372k symbols, the kernel uses 
a single RIP-relative instruction to jump directly to the root of the chain.
Direct access is the speed of light for the kernel.

================================================================================
SECTION 4: SOCKFS_OPS TABLE CONTENTS
================================================================================

sockfs_ops @ <span class="addr">0xffffffffbbd6e740</span>:

  +0:  alloc_inode  = <span class="addr">0xffffffffbb7ccda0</span>  (sock_alloc_inode)
  +8:  free_inode   = <span class="addr">0xffffffffbb7ccd60</span>  (sock_free_inode)
  +16: statfs       = <span class="addr">0xffffffffbae085d0</span>  (simple_statfs)

SOURCE: /usr/src/linux-source-6.8.0/net/socket.c

static const struct super_operations sockfs_ops = {
    .alloc_inode    = sock_alloc_inode,
    .free_inode     = sock_free_inode,
    .statfs         = simple_statfs,
};

================================================================================
SECTION 5: MEMORY POOL
================================================================================

sock_inode_cachep @ <span class="addr">0xffffffffbc38bda0</span>

This global pointer holds the address of the kmem_cache descriptor.
The descriptor manages a pool of 768-byte blocks.

<span class="cmd">$ sudo cat /proc/slabinfo | grep sock_inode</span>
sock_inode_cache  (pool for 768-byte socket_alloc structs)

Each socket() call:
  1. sock_alloc_inode reads sock_inode_cachep
  2. Calls kmem_cache_alloc with the pool address
  3. Pool returns a free 768-byte block
  4. Block contains: socket (0-127) + inode (128-751) + padding (752-767)

  DISASSEMBLY PROOF (The requested size):
  <span class="cmd">$ sudo gdb -batch -ex "disassemble sock_init" vmlinux</span>
  0xffffffff83b9bc0d &lt;+93&gt;:  mov $0x300,%esi
  (Truth: 0x300 = 768. The kernel binary requested 768 bytes.)

  SYSFS SLAB PROOF (The actual consumption):
  <span class="cmd">$ cat /sys/kernel/slab/sock_inode_cache/object_size</span>
  <span class="val">768</span>
  <span class="cmd">$ cat /sys/kernel/slab/sock_inode_cache/slab_size</span>
  <span class="val">832</span>
  (Truth: The RAM consumes 832 bytes per socket due to Redzones/Metadata.)

================================================================================
SECTION 6: PROOF THAT ARGUMENTS ARE IGNORED
================================================================================

sock_alloc() signature from net/socket.c:

    struct socket *sock_alloc(void)

The (void) means NO ARGUMENTS.

socket(2, 1, 0) passes 2, 1, 0 to __sys_socket.
__sys_socket calls sock_alloc().
sock_alloc() receives NOTHING.

Therefore:
  - sock_alloc() cannot see AF_INET (2)
  - sock_alloc() cannot see SOCK_STREAM (1)
  - sock_alloc() cannot see protocol (0)

The 720-byte allocation is IDENTICAL for:
  - socket(AF_INET, SOCK_STREAM, 0)
  - socket(AF_INET6, SOCK_DGRAM, 0)
  - socket(AF_UNIX, SOCK_SEQPACKET, 0)

SECTION 6B: THE ERASURE TRACE (CPU REGISTERS)
================================================================================

How the kernel physically destroys the protocol number 2:

1. AT CALL:    RDI = 0x00000002 (family)
2. HEIST:      0xffffffff821cc3f6: mov 0x18aa3a3(%rip), %rax (sock_mnt)
3. OVERWRITE:  0xffffffff821cc403: mov 0x8(%rax), %rdi (mnt_sb)

RESULT: RDI is overwritten with the Super Block address.
The number 2 is gone. The allocator (new_inode_pseudo) never sees it.

================================================================================
SECTION 7: LIVE VERIFICATION COMMANDS
================================================================================

<span class="cmd"># Verify kernel version</span>
cat /proc/version

<span class="cmd"># Verify boot time</span>
uptime -s

<span class="cmd"># Verify socket count</span>
cat /proc/net/sockstat | head -1

<span class="cmd"># Verify kernel symbols</span>
sudo grep sock_mnt /proc/kallsyms
sudo grep sock_alloc_inode /proc/kallsyms
sudo grep sockfs_ops /proc/kallsyms
sudo grep sock_inode_cachep /proc/kallsyms

<span class="cmd"># Verify sockfs source</span>
grep -A5 "sockfs_ops" /usr/src/linux-source-*/net/socket.c

================================================================================
SECTION 8: HEXADECIMAL ARITHMETIC
================================================================================

Example allocation block at <span class="addr">0xffff8f4e33230340</span>:

socket address = block + 0   = 0xffff8f4e33230340
inode address  = block + 128 = 0xffff8f4e33230340 + 0x80
                             = 0xffff8f4e332303c0

SOCKET_I macro does the reverse:
  inode address - 128 = socket address
  0xffff8f4e332303c0 - 0x80 = 0xffff8f4e33230340

================================================================================
                              END OF MACHINE DATA
================================================================================
    </pre>
</body>

</html>
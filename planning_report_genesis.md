# PLANNING REPORT: THE GENESIS OF A SOCKET (INSIDE-OUT GRILL)

**Target Audience:** Linus Torvalds, Richard Feynman.
**Constraint:** No solutions. No fluff. Pure probing questions.
## 0. EXISTING INTELLIGENCE (Recovered from Deep Scan)
The Deep Scan of `legacy_fluff/` (specifically `socket_theory.bak.html` and `05_kernel_deep_dive_proof.md`) revealed that we have already amassed significant intelligence on these phases. We must not reinvent the wheel, but rather *verify* these claims with the Linus Protocol.

### 0.1. The Archive's Claims
- **Design Time**: The "Centaur" design (Colocated Socket/Inode) is explicitly described as an optimization for VFS-to-Net coupling. `05_kernel_deep_dive_proof.md` maps the full pointer chain (`fd` -> `file` -> `private_data` -> `socket`).
- **Compile Time**: `socket_theory.bak.html` (Sec 01) claims `sockfs_ops` is sealed in `.rodata` and `sock_alloc_inode` in `.text`. It also mentions `sock_mnt` as a global anchor.
- **Boot Time**: `socket_theory.bak.html` (Sec 05) claims `sock_init()` calls `kmem_cache_create` and `kern_mount`. It even calculates the KASLR shift (`0x39600000`).

### 0.2. The Gap Analysis
While the *narrative* exists, the *Axiomatic Proofs* (The Linus Protocol) are missing for:
1.  **The "Sub" Instruction**: We claim `SOCKET_I` subtracts 128. We need to see the `lea -0x80(%rax)` in a verified `objdump`.
2.  **The Init Sequence**: We claim `sock_init` runs. We need a `dmesg` timestamp to prove *when* relative to `vfs_caches_init`.
3.  **The Linker Map**: We claim `sockfs_ops` is in `.rodata`. We need to `readelf` or `nm` to prove the section and flags.

---

## 1. THE MIDDLE: BOOT TIME (The Creation of Truth)
We know `kmalloc` and `kmem_cache_alloc` happen at runtime. But *who* set up the caches?

### 1.1. The Slab Creation
*   **Fact**: `01_slab_geometry.md` shows `sock_inode_cache` is 832 bytes (768 requested + 64 overhead).
*   **The Grill (Sub-Tasks)**:
    *   *Where* exactly in the boot sequence is `sock_init` called? Before or after `vfs_caches_init`?
    *   *Who* calls `kmem_cache_create`? Is it `net/socket.c`? 
    *   *Why* does it pass `SLAB_HWCACHE_ALIGN`? Who decided that? (Design Time link).
    *   *What* is the exact line of code in `dmesg` that proves `sock_init` ran? (We need to find this).

### 1.2. The Protocol Registration
*   **Fact**: `03_protocol_collision.md` proves `inetsw[1]` contains TCP and MPTCP.
*   **The Grill (Sub-Tasks)**:
    *   *When* does `inet_init` run?
    *   *How* does `inet_init` know about TCP? Does TCP register itself, or does INET pull it?
    *   *Why* is `inetsw` a hash table? Why not an array? (Design Time link).
    *   *Verify*: Is `inetsw` empty at T=0? Can we probe it before `inet_init`? (Philosophical question).

---

## 2. THE BEGINNING: COMPILE TIME (The Embedding of Truth)
Before boot, there is the ELF binary.

### 2.1. The Linker Sections
*   **Fact**: `axiomatic_probe_v2.c` finds `inetsw` via `kallsyms`.
*   **The Grill (Sub-Tasks)**:
    *   *Where* does `inetsw` live in the `vmlinux` binary? `.data`? `.bss`? `.rodata`?
    *   *How* does the compiler resolve `__NR_socket = 41`? (Preprocessor Truth).
    *   *What* does `objdump -t vmlinux | grep inetsw` tell us? (Size? Alignment?).
    *   *Why* is `tcp_prot` a global symbol? Is it exported?

### 2.2. The Macro Expansion
*   **Fact**: `SOCKET_I(inode)` is a macro.
*   **The Grill (Sub-Tasks)**:
    *   *How* does the preprocessor transform `container_of`?
    *   *Prove*: Show the *exact* instruction sequence generated by the compiler for `SOCKET_I`. Is it a `sub` instruction? (Compile Time Math).
    *   *Challenge*: Can we find the `sub $128, %reg` instruction in `kmem_cache_alloc` caller?

---

## 3. THE CONCEPT: DESIGN TIME (The Architecture of Truth)
Why did the kernel designers separate `sock` and `socket`?

### 3.1. The VFS Abstraction
*   **Fact**: `socket` contains `file`. `inode` points to `socket`.
*   **The Grill (Sub-Tasks)**:
    *   *Why* isn't `struct socket` just a field in `struct inode`? Why the pointer?
    *   *Why* does `sock_alloc_inode` exist? (The Centaur Pattern - avoiding the name, but questioning the structure).
    *   *Question*: If I only had `struct sock` (Network), how would VFS (Filesystem) talk to it? The `struct socket` is the *Adapter Pattern*. Prove this by analyzing fields.

### 3.2. The Inheritance Model
*   **Fact**: `tcp_sock` embeds `inet_connection_sock` embeds `inet_sock` embeds `sock`.
*   **The Grill (Sub-Tasks)**:
    *   *Why* C-style inheritance (struct embedding)?
    *   *What* happens if `struct sock` changes size? Do all protocols break? (ABI Stability).
    *   *Design Choice*: Why not `void *private_data`? (Performance? Cache alignment?).

---

## 4. THE EXECUTION PLAN (No Code Yet)
1.  **Probe Boot**: Use `dmesg` timestamp analysis to find `sock_init`.
2.  **Probe ELF**: Use `readelf`/`objdump` on the kernel (if available) or `System.map` to analyze `inetsw` placement.
3.  **Probe Logic**: Disassemble `sock_alloc` to find the `sub` instruction proving `container_of` at the assembly level.

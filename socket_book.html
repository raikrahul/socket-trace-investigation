<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>socket() Physical Implementation - Linux 6.14</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      background: #fff;
      color: #000;
      font-family: 'SF Mono', 'Consolas', monospace;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .master-container {
      display: flex;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .left-pane,
    .right-pane {
      flex: 1;
      padding: 40px;
      overflow: auto;
    }

    .left-pane {
      border-right: 1px solid #000;
    }

    pre {
      white-space: pre-wrap;
      font-family: 'SF Mono', 'Consolas', monospace;
      line-height: 1.4;
      margin: 0;
      padding: 10px;
      background: #282c34;
      border-radius: 4px;
      overflow-x: auto;
    }

    code {
      font-family: 'SF Mono', 'Consolas', monospace;
      display: block;
      padding: 0;
      background: transparent;
      color: #abb2bf;
    }

    .addr {
      color: #1f6feb;
      font-weight: 600;
    }
  </style>
</head>

<body>

  <div class="master-container">

    <div class="left-pane">
      <pre><code class="language-c">
SOCKET() PHYSICAL IMPLEMENTATION: LINUX 6.14.0-37-GENERIC
======================================================================

PHASE 1: PROGRAMS (SOURCE CODE)
======================================================================

THE BLUEPRINTS (net/socket.c):
  State: Text files on disk. logic defined in C structs.

  1. The Filesystem Type (DNA):
     static struct file_system_type sock_fs_type = {
         .name = "sockfs",
         .init_fs_context = sockfs_init_fs_context,
         .kill_sb = kill_anon_super,
     };

  2. The Operations Table (Behavior):
     static const struct super_operations sockfs_ops = {
         .alloc_inode = sock_alloc_inode,  /* <-- The Target */
         .statfs      = sockfs_statfs,
     };

  3. The Object Layout (Memory Map):
     struct socket_alloc {
         struct socket socket;  /* Offset 0 */
         struct inode vfs_inode; /* Offset 128 */
     } __attribute__((aligned(64)));

----------------------------------------------------------------------

PHASE 2: COMPILE & LINK (BINARY CONSTRUCTION)
======================================================================

STEP A: COMPILATION (gcc)
  - GCC reads `net/socket.c`.
  - It sees `sockfs_ops` uses `sock_alloc_inode`.
  - It creates a relocation entry: "Put the address of sock_alloc_inode HERE".
  - Output: `socket.o` (Relocatable Object).

STEP B: LINKING (ld)
  - LD combines `socket.o` with `fs/inode.o` etc.
  - Calculations:
    - `sock_alloc_inode` provided at address `0xffffffff821cc3f0`.
    - `sockfs_ops` placed at data address `0xffffffff8276e740`.
  - Action: LD writes `0xffffffff821cc3f0` into the first 8 bytes of `sockfs_ops`.
  - Result: The function pointer is physically wired before boot.

STEP C: RESOLVING EXTERNAL DEPENDENCIES (The Kernel Map)
  `socket.o` is not a standalone island. It relies on the Kernel Core (VFS & MMU).
  The Linker resolves these undefined symbols to absolute addresses (Verified via System.map).

  1. VFS INTEGRATION (To exist in the hierarchy):
     - `register_filesystem` @ `0xffffffff817f6c00`
       * Why: To add "sockfs" to the global list (/proc/filesystems).
     - `kern_mount` @ `0xffffffff817fa260`
       * Why: To create the `sock_mnt` anchor point.
     - `new_inode_pseudo` @ `0xffffffff817f2bf0`
       * Why: To allocate the "Base Class" (inode) for our socket object.

  2. MEMORY MANAGEMENT (To exist physically):
     - `kmem_cache_create` (@ `0xffffffff816cc730` as `__kmem_cache_create_args`)
       * Why: To reserve the specialized 832-byte slab pool.
     - `kmem_cache_alloc` (@ `0xffffffff8173afb0` as `kmem_cache_alloc_noprof`)
       * Why: To grab a physical object from that pool at runtime.

  * Implication: `net/socket.c` is hardwired to `fs/super.c` and `mm/slub.c` by these addresses.


----------------------------------------------------------------------

PHASE 3: BOOT (INITIALIZATION)
======================================================================

TRIGGER: `core_initcall(sock_init)`
  - Hardware boots -> Memory ready -> VFS ready -> `do_initcalls()`.

EXECUTION OF sock_init():
  
  1. `init_inodecache()`:
     - Calls `kmem_cache_create("sock_inode_cache", 768...)`.
     - Flags: `SLAB_HWCACHE_ALIGN` (align to 64 bytes).
     - Action: Pre-allocates empty Slab pages.
     - Result: 832-byte object pool ready.
     * AXIOM (WHY?): PHYSICS & SPEED. `kmalloc` is general-purpose and slow (O(log N)). Sockets are high-frequency objects. A dedicated Slab allows O(1) allocation and 0% external fragmentation by strictly segregating 832-byte chunks.

  2. `kern_mount(&sock_fs_type)` (The Wiring):
     - Calls `sockfs_init_fs_context()` -> sets `ctx->ops = &sockfs_ops`.
     - Calls `pseudo_fs_fill_super()` (fs/libfs.c).
     - Logic: `s->s_op = ctx->ops`.
     - Result: The Superblock now points to `sockfs_ops`.
     - Returns: `sock_mnt` (Global Anchor).
     * AXIOM (WHY?): THE VFS CONTRACT. The entire kernel I/O subsystem (read/write/close) operates on *inodes*. Sockets are immaterial (no disk), but they must "look" like files to exist in Unix. `kern_mount` creates a "Virtual Disk" (RAM-based) so sockets can wear the "Inode" uniform and use existing system calls.

  3. `sock_mnt` Assignment:
     - The address of the new vfsmount is stored in the global variable `sock_mnt`.
     - Verified Address: `0xffffffff83a767a0`.
     * AXIOM (WHY?): GLOBAL STATE. When a user calls `socket()`, the kernel needs an instant reference to this virtual filesystem's root. Searching for it would be slow. Storing the pointer in a global variable allows the CPU to load it in ONE instruction (`mov rip+offset`), enabling raw speed.


----------------------------------------------------------------------

PHASE 4: RUNTIME (EXECUTION)
======================================================================

USER CALL: `socket(AF_INET, SOCK_STREAM, 0)`

KERNEL EXECUTION CHAIN:
  `__sys_socket` -> `sock_create` -> `__sock_create` -> `sock_alloc()`

INSIDE sock_alloc() (The Physical Trace):

  1. RETRIEVE MOUNT POINT (RIP-Relative Load):
     - Instruction: `mov 0x18aa3a3(%rip), %rax`
     - Math: `RIP(0xffffffff821cc3fd) + 0x18aa3a3 = 0xffffffff83a767a0`
     - Result: RAX = `sock_mnt` (The anchor created in Phase 3).

  2. RETRIEVE SUPERBLOCK:
     - Instruction: `mov 0x8(%rax), %rdi`
     - Result: RDI = `sock_mnt->mnt_sb`.

  3. DISPATCH ALLOCATION (Function Pointer Jump):
     - Call: `alloc_inode(sb)`
     - Logic: `sb->s_op->alloc_inode(sb)`
     - Hardware: Jumps to `0xffffffff821cc3f0` (`sock_alloc_inode`).

  4. SLAB ALLOCATION:
     - `kmem_cache_alloc(sock_inode_cachep)`
     - Mechanics: Pop 1 pointer from per-CPU freelist. O(1).
     - Returns: 832-byte block (pointing to the inode part at +128).

  5. CENTAUR ARITHMETIC:
     - Instruction: `lea -0x80(%rax), %r12`
     - Math: `Inode_Ptr - 128 bytes = Socket_Ptr`.
     - Reason: We need the `struct socket`, which sits *before* the inode.

RESULT:
  - User gets a file descriptor.
  - Kernel holds a 832-byte object, aligned to cache lines, pinned to VFS.
</code></pre>
    </div>

    <div class="right-pane">
      <pre><code class="language-bash">
FORENSIC PROOFS: THE PHYSICAL EVIDENCE
======================================================================
The following data was extracted directly from the machine during the investigation.

PHASE 1: PROGRAMS (SOURCE & TOOLS)
======================================================================
$ uname -a
Linux i 6.14.0-37-generic #37~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC

$ gcc --version | head -n 1
gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0

$ grep -r "struct socket_alloc {" /usr/src/linux...
1555: struct socket_alloc {
1556:     struct socket socket;
1557:     struct inode vfs_inode;
1558: };

----------------------------------------------------------------------

PHASE 2: COMPILE & LINK (BINARY SYMBOLS)
======================================================================
$ nm /boot/vmlinux-6.14.0-37-generic | grep -E "sockfs_ops|sock_mnt"
ffffffff8276e740 d sockfs_ops
ffffffff83a767a0 b sock_mnt

$ readelf -S /boot/vmlinuz... | grep -E "\.data"
  .data     PROGBITS ffffffff83600000  02800000

$ pahole -C socket_alloc /boot/vmlinuz...
struct socket_alloc {
    struct socket  socket __attribute__((__aligned__(64))); /*   0   128 */
    struct inode   vfs_inode __attribute__((__aligned__(8))); /* 128   624 */
    /* size: 768 */
};

----------------------------------------------------------------------

PHASE 3: BOOT (INITIALIZATION TRACES)
======================================================================
$ gdb -batch -ex "disassemble sock_init" ...
   mov    $0x300,%esi           # 0x300 = 768 bytes (Slab Size)
   ...
   mov    %rax,-0x1254d9(%rip)  # Store in sock_mnt
   # Verified Target: 0xffffffff83a767a0

----------------------------------------------------------------------

PHASE 4: RUNTIME (EXECUTION STATE)
======================================================================
$ gdb -batch -ex "disassemble sock_alloc" ...
   +6:  mov 0x18aa3a3(%rip),%rax   # Load sock_mnt
   +19: mov 0x8(%rax),%rdi         # Load superblock
   +36: lea -0x80(%rax),%r12       # Centaur arithmetic (-128)

$ cat /proc/slabinfo | grep sock_inode
sock_inode_cache    2353   2652    832   39    8
   # Active Objects: 2353
   # Object Size: 832 bytes (768 + padding)
   # Total Memory: 1.87 MB

$ cat /proc/filesystems | grep sockfs
nodev   sockfs
</code></pre>
    </div>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>

</html>